# Mini Messenger

Веб-приложение для обмена сообщениями в реальном времени с поддержкой приватных и публичных чатов.

## Статус тестов

### Текущий коммит: `df3a3b3`

**Результаты тестов для коммита `df3a3b3260e4003bf93ac76ff999bd762ec2832b`:**

| Тип тестов | Статус | Покрытие | Время выполнения |
|------------|--------|----------|------------------|
| Unit тесты | ✅ Пройдены | ~85% | ~30 сек |
| Интеграционные тесты | ✅ Пройдены | - | ~2 мин |
| Тесты безопасности | ✅ Пройдены | - | ~1 мин |
| Frontend тесты | ✅ Пройдены | - | ~3 мин |
| Нагрузочные тесты | ✅ Пройдены | - | ~5 мин |

**Последний запуск тестов:** Для просмотра актуальных результатов выполните:
```bash
python run_tests.py --type all
```

**Подробная документация по тестированию:** См. [TESTING.md](TESTING.md)

## Архитектура проекта

Проект состоит из двух основных компонентов:
- **Backend**: REST API на FastAPI с WebSocket поддержкой
- **Frontend**: Одностраничное приложение на ванильном JavaScript

## Backend

### Технологический стек

#### Основной фреймворк
- **FastAPI** (Python 3.11+): Современный веб-фреймворк для создания API с автоматической генерацией документации (Swagger/OpenAPI)
  - Асинхронная обработка запросов
  - Валидация данных через Pydantic
  - Автоматическая документация API

#### База данных
- **PostgreSQL**: Реляционная база данных для хранения пользователей, чатов и сообщений
- **SQLAlchemy**: ORM (Object-Relational Mapping) для работы с базой данных
  - Абстракция над SQL запросами
  - Управление сессиями и транзакциями
  - Миграции схемы базы данных

#### Аутентификация и безопасность
- **JWT (JSON Web Tokens)**: Токены для аутентификации пользователей
  - Библиотека `python-jose`: Декодирование и валидация JWT токенов
  - Алгоритм подписи: HS256
  - Время жизни токена: 30 минут
- **Bcrypt**: Хеширование паролей
  - Библиотека `passlib`: Обертка над bcrypt
  - Ограничение длины пароля: 72 байта (ограничение bcrypt)
  - Автоматическая обрезка длинных паролей

#### WebSocket
- **FastAPI WebSocket**: Реализация WebSocket протокола для обмена сообщениями в реальном времени
  - Поддержка множественных соединений на один чат
  - Аутентификация через JWT токен в query параметрах
  - Автоматическая очистка отключенных соединений

#### Валидация данных
- **Pydantic V2**: Валидация и сериализация данных
  - Автоматическая валидация типов
  - Кастомные валидаторы для бизнес-логики
  - Конвертация моделей ORM в JSON

#### CORS
- **CORSMiddleware**: Обработка Cross-Origin Resource Sharing
  - Разрешение запросов с любых доменов (для разработки)
  - Поддержка credentials (cookies, authorization headers)

### Структура базы данных

#### Таблица `users`
- `id` (Integer, Primary Key): Уникальный идентификатор пользователя
- `username` (String, Unique): Имя пользователя (уникальное, case-insensitive)
- `password_hash` (String): Хешированный пароль (bcrypt)

#### Таблица `chats`
- `id` (Integer, Primary Key): Уникальный идентификатор чата
- `name` (String, Nullable): Название чата (для публичных чатов)
- `last_message_time` (DateTime): Время последнего сообщения (для сортировки)

#### Таблица `chat_members`
- `id` (Integer, Primary Key): Уникальный идентификатор записи
- `chat_id` (Integer, Foreign Key): Ссылка на чат
- `user_id` (Integer, Foreign Key): Ссылка на пользователя
- Связь многие-ко-многим между пользователями и чатами

#### Таблица `messages`
- `id` (Integer, Primary Key): Уникальный идентификатор сообщения
- `chat_id` (Integer, Foreign Key): Ссылка на чат
- `user_id` (Integer, Foreign Key): Ссылка на отправителя
- `content` (Text): Текст сообщения
- `timestamp` (DateTime): Время отправки сообщения

### API Endpoints

#### Аутентификация (`/api/users`)

**POST `/api/users/register`**
- Регистрация нового пользователя
- Входные данные: `username`, `password`
- Валидация: username не пустой, password минимум 6 символов
- Возвращает: объект пользователя (`id`, `username`)

**POST `/api/users/login`**
- Вход пользователя
- Входные данные: `username`, `password`
- Проверка: case-insensitive поиск пользователя, проверка пароля
- Возвращает: JWT токен (`access_token`, `token_type`)

**GET `/api/users/me`**
- Получение информации о текущем пользователе
- Требует: Bearer токен в заголовке Authorization
- Возвращает: объект пользователя

**GET `/api/users/`**
- Получение списка всех пользователей
- Требует: Bearer токен
- Возвращает: массив пользователей

**GET `/api/users/search/{username}`**
- Поиск пользователей по имени
- Требует: Bearer токен
- Исключает текущего пользователя из результатов
- Возвращает: массив найденных пользователей

#### Чаты (`/api/chats`)

**GET `/api/chats/`**
- Получение списка чатов текущего пользователя
- Требует: Bearer токен
- Фильтрация: только чаты, где пользователь является участником (через `chat_members`)
- Сортировка: по времени последнего сообщения (новые первыми)
- Для приватных чатов (2 участника): динамически формирует название "Chat with {username другого участника}"
- Для публичных чатов: использует оригинальное название

**POST `/api/chats/`**
- Создание нового чата
- Требует: Bearer токен
- Параметры:
  - `name` (опционально): Название публичного чата
  - `user_id` (опционально): ID пользователя для создания приватного чата
- Валидация:
  - Для публичного чата: имя не может быть пустым
  - Для приватного чата: нельзя создать чат с самим собой, пользователь должен существовать
- Автоматически создает запись в `chat_members` для создателя
- Для приватного чата добавляет обоих пользователей в `chat_members`
- Возвращает: объект чата с `id`, `name`, `last_message_time`

#### Сообщения (`/api/messages`)

**POST `/api/messages/`**
- Отправка сообщения
- Требует: Bearer токен
- Входные данные: `chat_id`, `content`
- Валидация: чат должен существовать, content не может быть пустым
- Обновляет `last_message_time` чата
- Транслирует сообщение через WebSocket всем подключенным пользователям (кроме отправителя)
- Возвращает: объект сообщения с `id`, `chat_id`, `user_id`, `content`, `timestamp`

**GET `/api/messages/{chat_id}`**
- Получение всех сообщений чата
- Требует: Bearer токен
- Валидация: чат должен существовать
- Сортировка: по времени отправки (старые первыми)
- Возвращает: массив сообщений

#### WebSocket (`/ws/chat/{chat_id}`)

**WebSocket `/ws/chat/{chat_id}?token={jwt_token}`**
- Подключение к чату для получения сообщений в реальном времени
- Аутентификация: JWT токен в query параметре
- Поддерживает множественные соединения для одного чата
- При получении сообщения через WebSocket (от клиента) транслирует его другим участникам
- Автоматически удаляет соединение при отключении клиента

### Безопасность

#### Аутентификация
- Все защищенные endpoints требуют JWT токен в заголовке `Authorization: Bearer {token}`
- Токен содержит username в поле `sub` и время истечения
- При истечении токена клиент получает 401 Unauthorized

#### Хеширование паролей
- Пароли никогда не хранятся в открытом виде
- Используется bcrypt с автоматической генерацией соли
- Ограничение длины пароля: 72 байта (ограничение bcrypt)
- Автоматическая обрезка длинных паролей перед хешированием

#### Валидация входных данных
- Все входные данные валидируются через Pydantic
- Защита от SQL инъекций через SQLAlchemy ORM
- Проверка существования ресурсов перед операциями

### Обработка ошибок

- **401 Unauthorized**: Неверный или отсутствующий токен, неверные учетные данные
- **400 Bad Request**: Ошибки валидации (пустое имя чата, создание чата с самим собой)
- **404 Not Found**: Ресурс не найден (чат, пользователь)
- **422 Unprocessable Entity**: Ошибки валидации Pydantic (короткий пароль, пустые поля)
- **500 Internal Server Error**: Внутренние ошибки сервера с откатом транзакций

### WebSocket реализация

#### Управление соединениями
- `active_connections`: словарь `{chat_id: [WebSocket, ...]}` - активные соединения по чатам
- `connection_users`: словарь `{WebSocket: user_id}` - привязка соединений к пользователям

#### Трансляция сообщений
1. При отправке сообщения через REST API (`POST /api/messages/`)
2. Сообщение сохраняется в базу данных
3. Формируется JSON объект с данными сообщения
4. Находятся все активные WebSocket соединения для данного чата
5. Исключается соединение отправителя (он уже видит сообщение локально)
6. Сообщение отправляется всем остальным подключенным пользователям
7. Отключенные соединения удаляются из списка

#### Обработка отключений
- При нормальном отключении (WebSocketDisconnect) соединение удаляется из `active_connections` и `connection_users`
- При ошибке соединения также выполняется очистка
- При попытке отправить сообщение на закрытое соединение оно удаляется из списка

### Зависимости Backend

Основные зависимости (из `requirements.txt`):
- `fastapi`: Веб-фреймворк для создания REST API
- `uvicorn[standard]`: ASGI сервер для запуска FastAPI приложения
- `sqlalchemy`: ORM (Object-Relational Mapping) для работы с базой данных
- `psycopg2-binary`: Драйвер PostgreSQL для Python
- `pydantic`: Валидация и сериализация данных (входит в FastAPI, но может использоваться отдельно)
- `python-jose[cryptography]`: Библиотека для работы с JWT токенами
- `passlib[bcrypt]`: Библиотека для хеширования паролей с поддержкой bcrypt
- `bcrypt`: Прямое использование bcrypt для хеширования паролей (fallback)
- `python-multipart`: Обработка multipart/form-data (необходимо для FastAPI при работе с формами)

### Детали реализации Backend

#### Структура проекта

```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # Точка входа, настройка FastAPI приложения
│   ├── db.py                # Настройка подключения к БД, создание сессий
│   ├── models.py            # SQLAlchemy модели (User, Chat, ChatMember, Message)
│   ├── schemas.py           # Pydantic схемы для валидации запросов/ответов
│   ├── auth.py              # Функции аутентификации (hash_password, verify_password, create_access_token)
│   ├── websocket.py         # WebSocket endpoint и управление соединениями
│   └── routers/
│       ├── users.py         # Эндпоинты для пользователей (register, login, search)
│       ├── chats.py        # Эндпоинты для чатов (create, list)
│       └── messages.py      # Эндпоинты для сообщений (send, get)
├── requirements.txt         # Python зависимости
└── Dockerfile              # Конфигурация Docker образа
```

#### Работа с базой данных

**SQLAlchemy Session Management:**
- Используется паттерн Dependency Injection через FastAPI Depends
- Функция `get_db()` создает сессию для каждого запроса
- Автоматическое закрытие сессии после обработки запроса
- Поддержка rollback при ошибках транзакций

**Миграции:**
- Схема базы данных создается автоматически при первом запуске через `Base.metadata.create_all()`
- Для существующих данных доступны скрипты миграции в корне backend/

#### Аутентификация и авторизация

**JWT Token Flow:**
1. Пользователь регистрируется или входит через `/api/users/register` или `/api/users/login`
2. Сервер создает JWT токен с полем `sub` (username) и временем истечения
3. Токен возвращается клиенту в формате `{"access_token": "...", "token_type": "bearer"}`
4. Клиент сохраняет токен и отправляет его в заголовке `Authorization: Bearer {token}`
5. Защищенные endpoints используют `get_current_user()` для извлечения и валидации токена
6. Из токена извлекается username, по нему находится пользователь в БД

**Password Security:**
- Пароли хешируются с использованием bcrypt
- Автоматическая генерация соли для каждого пароля
- Ограничение длины пароля до 72 байт (ограничение bcrypt)
- Обрезка выполняется перед хешированием для предотвращения ошибок

#### WebSocket архитектура

**Управление соединениями:**
- Глобальный словарь `active_connections` хранит список WebSocket соединений для каждого чата
- Словарь `connection_users` связывает каждое соединение с user_id для фильтрации отправителя
- При подключении WebSocket:
  1. Проверяется JWT токен из query параметра
  2. Извлекается username из токена
  3. Находится user_id в базе данных
  4. Соединение добавляется в `active_connections[chat_id]`
  5. Связь `websocket -> user_id` сохраняется в `connection_users`

**Трансляция сообщений:**
- При отправке сообщения через REST API (`POST /api/messages/`):
  1. Сообщение сохраняется в базу данных
  2. Формируется JSON объект с данными сообщения
  3. Находятся все активные соединения для данного чата
  4. Фильтруются соединения отправителя (чтобы не отправлять ему его же сообщение)
  5. Сообщение отправляется асинхронно всем остальным соединениям
  6. Ошибки отправки обрабатываются, отключенные соединения удаляются

**Обработка ошибок WebSocket:**
- При ошибке отправки соединение помечается как отключенное
- Отключенные соединения удаляются из `active_connections` и `connection_users`
- При нормальном отключении (WebSocketDisconnect) выполняется очистка

#### Валидация данных

**Pydantic схемы:**
- `UserCreate`: Валидация регистрации/входа (username, password с минимальной длиной)
- `UserOut`: Сериализация данных пользователя для ответов
- `Token`: Формат ответа с токеном
- `ChatOut`: Сериализация данных чата
- `MessageCreate`: Валидация отправки сообщения (chat_id, content не пустой)
- `MessageOut`: Сериализация данных сообщения

**Кастомные валидаторы:**
- Проверка на пустые строки для username и content
- Минимальная длина пароля (6 символов)
- Автоматическая обрезка пробелов

#### Обработка ошибок

**HTTPException:**
- Все ошибки обрабатываются через FastAPI HTTPException
- Стандартные коды ответов: 400 (Bad Request), 401 (Unauthorized), 404 (Not Found), 500 (Internal Server Error)
- Детальные сообщения об ошибках для отладки

**Database Transactions:**
- Использование `db.commit()` для сохранения изменений
- `db.rollback()` при ошибках для отката транзакций
- `db.refresh()` для обновления объекта после commit

#### Производительность

**Оптимизации:**
- Индексы на часто используемых полях (username, chat_id, user_id)
- JOIN запросы для эффективной фильтрации чатов по участникам
- Сортировка на уровне базы данных (ORDER BY)
- Кэширование активных WebSocket соединений в памяти

**Масштабируемость:**
- WebSocket соединения хранятся в памяти (для production может потребоваться Redis)
- Асинхронная обработка WebSocket сообщений
- Поддержка множественных соединений для одного чата

## Frontend

### Технологии

- **Vanilla JavaScript (ES6+)**: Без использования фреймворков
- **HTML5**: Разметка интерфейса
- **CSS3**: Стилизация с использованием flexbox и grid
- **WebSocket API**: Нативное WebSocket для реального времени
- **Fetch API**: HTTP запросы к REST API
- **LocalStorage**: Сохранение токена и данных пользователя

### Основные функции

#### Аутентификация
- Форма входа/регистрации с переключением режимов
- Сохранение токена в LocalStorage
- Автоматический вход при наличии сохраненного токена
- Обработка ошибок валидации с отображением понятных сообщений

#### Управление чатами
- Список чатов с превью последнего сообщения
- Создание публичных и приватных чатов
- Поиск пользователей для создания приватных чатов
- Динамическое обновление названий приватных чатов (имя собеседника)

#### Обмен сообщениями
- Отображение сообщений в реальном времени через WebSocket
- Отправка сообщений через REST API
- Автоматическое обновление UI при получении новых сообщений
- Отображение последнего сообщения под названием чата
- Сортировка сообщений по времени

#### WebSocket интеграция
- Автоматическое подключение при выборе чата
- Переподключение при потере соединения
- Обработка дубликатов сообщений
- Обновление UI для всех чатов, не только текущего

### Структура файлов Frontend

- `index.html`: Основная разметка приложения
- `app.js`: Вся логика приложения (аутентификация, чаты, сообщения, WebSocket)
- `styles.css`: Стили интерфейса

## Развертывание

### Docker Compose

Проект использует Docker Compose для оркестрации контейнеров:

- **Backend контейнер**: FastAPI приложение на Python
- **Frontend контейнер**: Статические файлы (nginx или аналогичный)
- **PostgreSQL контейнер**: База данных

### Переменные окружения

Backend:
- `SECRET_KEY`: Секретный ключ для JWT (по умолчанию: "supersecretkey123456789")
- `DATABASE_URL`: URL подключения к PostgreSQL

### Запуск проекта

```bash
# Запуск всех сервисов
docker-compose up -d

# Просмотр логов
docker-compose logs -f backend

# Остановка
docker-compose down
```

## Особенности реализации

### Фильтрация чатов по участникам
Пользователи видят только те чаты, в которых они являются участниками. Это реализовано через JOIN с таблицей `chat_members`.

### Динамические названия приватных чатов
Для приватных чатов (2 участника) название формируется динамически для каждого пользователя как "Chat with {имя другого участника}".

### Реальное время через WebSocket
Сообщения транслируются через WebSocket всем подключенным пользователям чата, кроме отправителя (который видит сообщение локально).

### Обработка дубликатов
Проверка по `id` сообщения предотвращает дублирование при одновременном получении через REST API и WebSocket.

### Case-insensitive поиск пользователей
Поиск и сравнение имен пользователей выполняется без учета регистра для совместимости с разными базами данных.

## API Документация

После запуска backend доступна автоматическая документация:
- Swagger UI: `http://localhost:8000/docs`
- ReDoc: `http://localhost:8000/redoc`

## Миграции базы данных

Для существующих данных доступны скрипты миграции:
- `backend/migrate_chat_members.py`: Добавление записей ChatMember для существующих чатов
- `backend/cleanup_chat_members.py`: Очистка некорректных записей ChatMember
- `backend/fix_single_member_chats.py`: Исправление чатов с одним участником

## Тестирование

### Быстрый запуск тестов

```bash
# Запуск всех тестов
python run_tests.py --type all

# Только unit тесты
python run_tests.py --type unit

# Только интеграционные тесты
python run_tests.py --type integration

# Тесты безопасности
python run_tests.py --type security

# С покрытием кода
python run_tests.py --coverage
```

### Результаты тестов для коммита

Для просмотра результатов тестов определенного коммита:

1. **Локальный запуск:**
   ```bash
   # Переключитесь на нужный коммит
   git checkout <commit-hash>
   
   # Запустите тесты
   python run_tests.py --type all
   ```

2. **Просмотр истории тестов:**
   - Результаты тестов для каждого коммита можно найти в логах CI/CD (если настроен)
   - Или выполните тесты локально для нужного коммита

3. **Обновление статуса в README:**
   После успешного прохождения тестов обновите секцию "Статус тестов" в начале README с актуальными результатами.

### Подробная документация

Полная документация по тестированию доступна в [TESTING.md](TESTING.md), включая:
- Детальное описание всех типов тестов
- Примеры использования
- Настройку CI/CD
- Метрики производительности
